// control.proto: protocol messages for the client control socket.
//
// Feel free to change this file, but:
//
// ************************************************************************
// ********************* DO NOT ADD REQUIRED FIELDS. **********************
// ********************* DO NOT ADD REQUIRED FIELDS. **********************
// ********************* DO NOT ADD REQUIRED FIELDS. **********************
// ********************* DO NOT ADD REQUIRED FIELDS. **********************
// ************************************************************************
//
//
// ************************************************************************
// ************ ALWAYS USE [packed=true] IN REPEATED FIELDS. **************
// ************ ALWAYS USE [packed=true] IN REPEATED FIELDS. **************
// ************ ALWAYS USE [packed=true] IN REPEATED FIELDS. **************
// ************ ALWAYS USE [packed=true] IN REPEATED FIELDS. **************
// ************************************************************************
//

//////////////////////////////////////////////////////////////////////
// Shared datatypes

// Sample type
enum SampleType {
    BOARD_SUBSAMPLE = 0;
    BOARD_SAMPLE = 1;
}

// How to store samples on disk
enum StorageBackend {
    STORE_HDF5 = 1;            // Write to HDF5 file
    STORE_RAW = 2;             // Write raw packets (for benchmarking)
}

//////////////////////////////////////////////////////////////////////
// Register I/O primitives
//
// For low-level or debugging use.

//
// Per-module registers
//
// These are the registers exposed by the data node, grouped by module.
//

enum Module {
    MOD_ERR = 0;
    MOD_CENTRAL = 1;
    MOD_SATA = 2;
    MOD_DAQ = 3;
    MOD_UDP = 4;
    MOD_GPIO = 5;
}

enum ErrAddr {
    ERR_ERR0 = 0;
}

enum CentralAddr {
    CENTRAL_ERR = 0;
    CENTRAL_STATE = 1;
    CENTRAL_COOKIE_H = 2;
    CENTRAL_COOKIE_L = 3;
}

enum SataAddr {
    SATA_ERR = 0;
    SATA_STATE = 1;
    SATA_DISK_ID = 2;
    SATA_DISK_PARAM = 3;
    SATA_NEXT_READ = 4;     // in board samples
    SATA_READ_LEN = 5;
    SATA_LAST_WRITE = 6;    // in board samples
}

enum DaqAddr {
    DAQ_ERR = 0;
    DAQ_STATE = 1;
    DAQ_START_BSAMP = 2;
    DAQ_CURR_BSAMP = 3;
    DAQ_CHIP_ALIVE = 4;
    DAQ_CMD_IO = 5;
    DAQ_SYNCHRONOUS = 6;
    DAQ_FIFO_COUNT = 7;
    DAQ_SUBSAMP_CHIP0 = 16;
    DAQ_SUBSAMP_CHIP1 = 17;
    DAQ_SUBSAMP_CHIP2 = 18;
    DAQ_SUBSAMP_CHIP3 = 19;
    DAQ_SUBSAMP_CHIP4 = 20;
    DAQ_SUBSAMP_CHIP5 = 21;
    DAQ_SUBSAMP_CHIP6 = 22;
    DAQ_SUBSAMP_CHIP7 = 23;
    DAQ_SUBSAMP_CHIP8 = 24;
    DAQ_SUBSAMP_CHIP9 = 25;
    DAQ_SUBSAMP_CHIP10 = 26;
    DAQ_SUBSAMP_CHIP11 = 27;
    DAQ_SUBSAMP_CHIP12 = 28;
    DAQ_SUBSAMP_CHIP13 = 29;
    DAQ_SUBSAMP_CHIP14 = 30;
    DAQ_SUBSAMP_CHIP15 = 31;
    DAQ_SUBSAMP_CHIP16 = 32;
    DAQ_SUBSAMP_CHIP17 = 33;
    DAQ_SUBSAMP_CHIP18 = 34;
    DAQ_SUBSAMP_CHIP19 = 35;
    DAQ_SUBSAMP_CHIP20 = 36;
    DAQ_SUBSAMP_CHIP21 = 37;
    DAQ_SUBSAMP_CHIP22 = 38;
    DAQ_SUBSAMP_CHIP23 = 39;
    DAQ_SUBSAMP_CHIP24 = 40;
    DAQ_SUBSAMP_CHIP25 = 41;
    DAQ_SUBSAMP_CHIP26 = 42;
    DAQ_SUBSAMP_CHIP27 = 43;
    DAQ_SUBSAMP_CHIP28 = 44;
    DAQ_SUBSAMP_CHIP29 = 45;
    DAQ_SUBSAMP_CHIP30 = 46;
    DAQ_SUBSAMP_CHIP31 = 47;
}

enum UdpAddr {
    UDP_ERR = 0;
    UDP_STATE = 1;
    UDP_SRC_MAC48_H = 2;
    UDP_SRC_MAC48_L = 3;
    UDP_DST_MAC48_H = 4;
    UDP_DST_MAC48_L = 5;
    UDP_SRC_IPV4_ADDR = 6;
    UDP_DST_IPV4_ADDR = 7;
    UDP_SRC_IPV4_PORT = 8;
    UDP_DST_IPV4_PORT = 9;
    UDP_TX_COUNT = 10;
    UDP_ETHPKT_LEN = 11;
    UDP_PAYLOAD_LEN = 12;
}

enum GpioAddr {
    GPIO_ERR = 0;
    // [there's no GPIO state machine]
    GPIO_READ = 2;
    GPIO_WRITE = 3;
    GPIO_STATE = 4;
}

// Direct register I/O message.
//
// This is intended for for low-level and debugging use.
//
// You can embed a RegisterIO within a ControlCommand and send it to
// the daemon to do register I/O. If you do, you'll get the result of
// the I/O back in another RegisterIO embedded in a
// ControlResponse. (See below for the definitions of ControlCommand
// and ControlResponse).

message RegisterIO {
    // Choice of type specifies which group of registers (which
    // module) you can use.  You must provide a value for "type":
    optional Module module = 1;

    // Register value. Provide "val" on a write; don't on a read:
    optional fixed32 val = 2;

    // Register address. Provide exactly one of these, depending on 'type'.
    optional ErrAddr err = 3;
    optional CentralAddr central = 4;
    optional SataAddr sata = 5;
    optional DaqAddr daq = 6;
    optional UdpAddr udp = 7;
    optional GpioAddr gpio = 8;
}

//////////////////////////////////////////////////////////////////////
// Commands
//
// To perform a command:
//
// - Initialize a ControlCommand protocol message,
// - pack it into a protocol buffer, and
// - send that prefixed by its length as a uint32 to the daemon's
//   client control socket.
//
// See the script 'exchange-protobuf' for an example.
//
// In return, you'll get a ControlResult (see below).

// Configure a live stream. Currently, only subsamples are supported.
//
// If you set one of dest_udp_addr4 and dest_udp_port, you must set
// the other as well.
//
// If "enable" is present and true, you'll start to get BoardSubsample
// (see data.proto) messages via UDP at IPv4 address "dest_udp_addr4",
// on port "dest_udp_port". You can omit the address/port if you've
// previously configured them and just want to turn the stream back on
// again. Results are unspecified if you enable the stream without
// having previously configured its destination.
//
// If "enable" is present and false, any existing stream will stop
// being sent. If dest_udp_addr4 and dest_udp_port are present in this
// case, the order between the events "stream is disabled" and "stream
// is reconfigured" is undefined. Send two messages if you need a
// reliable order.
message ControlCmdStream {
    optional fixed32 dest_udp_addr4 = 1;
    optional uint32 dest_udp_port = 2;
    optional bool enable = 3;
}

// Store board samples received from the daemon to disk.
//
// This command can be used to store live or pre-recorded samples. To
// store live samples, leave "start_sample" missing. To store
// pre-recorded samples, specify "start_sample". You can't store
// pre-recorded samples while a live capture is ongoing.
//
// If any samples get stored, you'll get a ControlResponse with
// type==SUCCESS and an embedded ControlResStore in return. The
// embedded ControlResStore will tell you how many samples got stored.
// This number may be less than what you requested if some packets
// were dropped during live capture storage.
//
// If sample storage fails completely, you'll get a ControlResponse
// with type==ERR.
message ControlCmdStore {
    // Where to store samples; must be present.
    optional string path = 1;

    // How many samples to store; must be present.
    optional uint32 nsamples = 2;

    // What sample index should arrive first. If missing, the count
    // will start from the first sample that gets received.
    optional uint32 start_sample = 3;

    // What type of file to store samples into; defaults to HDF5.  If
    // missing, samples won't be stored. If present, sample_type must
    // be BOARD_SAMPLE.
    optional StorageBackend backend = 17;
}

// Follows union type guidelines as described here:
// https://developers.google.com/protocol-buffers/docs/techniques#union
message ControlCommand {
    enum Type {
        STREAM = 1;
        STORE = 2;
        REG_IO = 255;
    }
    optional Type type = 1;

    optional ControlCmdStream stream = 2;
    optional ControlCmdStore store = 3;
    optional RegisterIO reg_io = 15;
}

//////////////////////////////////////////////////////////////////////
// Results
//
// These are sent from daemon to client on the client control socket
// to indicate the result of a ControlCommand.
//
// You may receive ControlResErr error packets when the data node
// asynchronously signals an error. In this case, the ErrCode field
// will be set to DNODE_ASYNC.

// Error response
message ControlResErr {
    enum ErrCode {
        // No data node connected
        NO_DNODE = 0;
        // Internal daemon error
        DAEMON = 1;
        // Daemon I/O error
        DAEMON_IO = 6;
        // Protocol error on client control socket
        C_PROTO = 2;
        // Protocol error on data node control socket
        D_PROTO = 3;
        // Data node transaction failed
        DNODE = 4;
        // Asynchronous data node error
        DNODE_ASYNC = 5;
    }
    optional ErrCode code = 1;
    optional string msg = 2;
}

// Success response for a ControlCmdStore.
message ControlResStore {
    enum Status {
        DONE = 1;               // Finished successfully
        ERROR = 2;              // Unknown error
        PKTDROP = 3;            // Packet was dropped
        TIMEOUT = 4;            // Timed out waiting for packets
    }
    optional Status status = 1;   // "Exit" status
    optional string path = 2;     // Path data got stored to.
    optional uint32 nsamples = 3; // Number of samples written.
}

message ControlResponse {
    enum Type {
        ERR = 1;
        // If type==SUCCESS, the previous command succeeded; no other
        // fields will be set.
        SUCCESS = 2;
        STORE_FINISHED = 3;
        REG_IO = 255;
    }
    optional Type type = 1;

    optional ControlResErr err = 2; // when type==ERR
    optional ControlResStore store = 3; // when type==STORE_FINISHED
    optional RegisterIO reg_io = 15; // when type==REG_IO
}
