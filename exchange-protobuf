#!/usr/bin/env python

from __future__ import print_function

import contextlib
from os.path import abspath, basename, dirname, join
import socket
import struct
import sys

import google.protobuf.text_format

# Tack our protobuf ser/des directory onto sys.path
script_file = abspath(__file__)
pyproto_dir = join(dirname(script_file), 'build', 'pyproto', 'proto')
sys.path.append(pyproto_dir)

import control_pb2

# Parse arguments
def usage():
    print('usage: %s <protobuf-text-file> <dest-port>' % basename(script_file))
    sys.exit(1)

if len(sys.argv) != 3:
    usage()
try:
    with open(sys.argv[1]) as pbuf_f:
        pbuf_txt = pbuf_f.read()
    dst_port = int(sys.argv[2])
except:
    usage()

# Serialize the command
cmd = control_pb2.ControlCommand()
google.protobuf.text_format.Merge(pbuf_txt, cmd)

# Connect to daemon
sckt = socket.create_connection(('127.0.0.1', dst_port))
if not sckt:
    print("can't create connection", file=sys.stderr)
    sys.exit(1)

# Round-trip: send message, get response
with contextlib.closing(sckt) as sckt:
    ser = cmd.SerializeToString()
    sckt.send(struct.pack('>l', len(ser)))
    sckt.send(ser)
    resplen_net = sckt.recv(4)
    if len(resplen_net) == 4:
        resplen = struct.unpack('>l', resplen_net)[0]
        pbuf_resp = sckt.recv(resplen)
    else:
        pbuf_resp = None

# Display response
if pbuf_resp:
    rsp = control_pb2.ControlResponse()
    rsp.ParseFromString(pbuf_resp)
    google.protobuf.text_format.PrintMessage(rsp, sys.stdout)
else:
    print("Error; didn't get complete response", file=sys.stderr)
