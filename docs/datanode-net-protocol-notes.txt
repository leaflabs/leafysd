NB:

- These are notes. They are incomplete and not yet a coherent draft or
  proposal.
- This file uses terms defined in system-overview.txt.

TODO:

- Board subsample configuration requests
- Sector-based I/O commands

# Context

This document proposes a network protocol for bi-directional data acquisition
and control communications between a "Wired Leaf" data node and a daemon
running on an analysis server or user workstation.

It is a design goal that at least a useful subset of this protocol can be
implemented in HDL running on the FPGA so that a basic system can be brought
online without any additional processor firmware beyond a trivial management of
the TCP interface and data pass through.

To achieve this property, each of the primary cores that comprise the FPGA
firmware will expose key operational and configuration registers to a global
regmap. This regmap can be accessed via this protocol. Thus, the burden of the
application and other glue logic *can* be moved to the remote server by issuing
longer sequences of reads and writes on this exposed regmap.

Ideally, any command which poses a substantial additional burden on the logic of
the FPGA core or demands the inclusion of substantial firmware running on a soft
or hard processor can be circumvented via an appropriate sequence of operations
on the system registers.

The data node SHOULD process one command or request (aside from live data
streaming) at a time; if another request arrives while processing, it MAY queue
the request or reply with an error.

Two sockets are used: one bi-directional command/control socket (type
SOCK_STREAM), and one uni-directional data socket (type SOCK_DGRAM). The data
socket is used to stream sample data from the FPGA board to the computer. The
command socket is bidirectional and low-bandwidth; the data socket is
unidirectional and high-bandwidth.

# Packet Format

TODO: decide on port numbers

The source address serves to identify the unique acquisition device. All
packets have a fixed size.

    [UDP/IPv4 pseudo header]
        Source address (4byte)
        Destination address (4byte)
        Zeros (0x00) | Protocol Number (0x11 for UDP) | UDP length (2byte)
    [UDP header]
        Source Port (2byte) | Destination Port (2byte)
        Length (2byte) | Checksum (2byte)
    [SNG Wire Format Header]
        Magic number (1byte) | Proto Version (1byte) | Message Type (1byte) | Misc Flags (1byte)
    [Status]
        status flags (4bytes)
    [SNG Message Data]
        (contents depend upon Message Type. Length fixed to 16 bytes on command
        socket; variable on data socket)

The Status word has up to 32 flags to indicate various error or reserved conditions.
If any bit is high, the daemon should read and write to specific registers
using request packets to resolve the error and reset the flag bits. Specific
meanings for these bits are  currently unspecified.

The valid values for the Message Type field, and their meanings, are:

- Request: 0x02
- Response: 0x03
- Board subsample: 0x04
- Board Sample Packets: 0x05
- Remote Error: 0x06

# Message Types

## Request (0x02)

A packet with Message type equal to 0x02 indicates a request. Request packets
are sent only from the daemon to the data node, on the command socket.

Additional flags:

- I/O direction: bit 0 signals whether a request which performs some sort of
  input/output is a read (bit 0 set) or a write (bit 0 uset).

Message Data:

    Request ID (2byte) | Request Type (1byte) | Request Address (1byte, or zeros)
    Extra data (12 bytes, or garbage)

The Request ID field is used to associate responses with requests. The request
ID field SHOULD be an incrementing 16-bit unsigned integer which wraps back to
zero after 0xFFFF is reached. While the command socket uses TCP, thus obviating
the need for the Request ID field, some responses are transmitted over the data
socket, which is UDP.


The Request Type field identifies the data node subsystem to which the request
pertains. Each of the request types correspond to a specific HDL core that
comprises the toplevel FPGA firmware. This guarantees that each such module has
a full byte of address space dedicated to its own registers.
Valid Request Types are:

- Storage/disk (0x02): e.g. disk sector index, I/O status
- DAQ (0x03): e.g. reconfiguration of front end, impedance measurement
- Network (0x04): e.g. source/dest IP address, dest. MAC address
- Expansion (0x05): e.g. GPIO configuration for expansion header pins
- Acquisition (0x06): start, stop acquisition, configure board subsample
- Retrieval (0x07): Read board sample packets off disk.
- Error (0x08)

The Request Address field identifies a register address. Whether the request is
for a read or write to the address is determined by the I/O direction flag
discussed above.

Currently, all specified registers are 8-bits long. Accessing registers that are
functionally longer than 1 byte - for example the dest MAC accress - must be
done over multiple packets. This is done for ease of implementation. It is
expected that in the future specific registers may vary in length between 1 and
12 bytes.

### Storage/Disk (0x02)
### DAQ (0x03)
### Network (0x04)
### Expansion (0x05)
### Acquisition (0x06)

### Retrieval (0x07)

### Error (0x08)
There is only one error register, 0x00, which must be cleared in order to allow
additional error packets to be transmitted over the asynchronous error channel.

## Response (0x3)

A Response packet contains the same fields as a request packet. Response
packets are sent from the data node to the daemon, on the command socket. The
meaning of the I/O direction flag in a response packet is not defined.

After processing a request packet, the data node replies with a response
packet. The response packet has the same Request ID as that in the request
packet. The Request Type and Request Address fields in the response packet
SHOULD be the same as those in the request packet.

TODO: spec out Message Data when different from Request packets

## Board Subsample (0x4)

Contains a variable number of channel samples, all taken from the same board
sample. Board subsample packets are sent only from the data node to the daemon,
on the data socket.

Additional flags:

- Is last sample: bit 1 set indicates no more samples will follow; this makes
  daemon control structure much simpler.

Message Data:

    Start sample index (4 byte)
    NSAMP=Number of samples (4 byte)
    [... sequence of NSAMP channel readings ]

The start sample index indicates the index of the first channel in the
subsample, relative to the start of the board sample. We use 32 bits to allow
for future expansion to systems with more than 65K channels.

Sample indexes are calculated as follows:

    sample index 0 = chip 0, channel 0
    sample index 1 = chip 0, channel 1
    ...
    sample index n = chip 0, channel n
    sample index n+1 = chip 1, channel 0

TBD: multiple board subsamples may get bundled into a single "Board Subsample"
to improve aggregate data throughput?

NB: Board Subsample packets, which are received over the data socket, are
likely to be of a fixed length (18kilobit?), regardless of how much meaningful
data is enclosed.


## Board Sample Packet (0x05)

<<<<<<< HEAD
A Board Sample Packet contains a complete board sample - roughly 18kb - along
with a sample ID.

TBD: ideally there is exactly one type of on-disk data object. This should be
that object. Is there anything else we want to include besides the data? sample
ID, wall clock timestamp, recording ID, ? If so then a board sample packet is
comprised of a header, which includes the fields above, and then the data in
roughly the same format they are stored on disk.

Board sample packets are retrieved by request packets being sent of type 0x06.


## Error Packet (0x06)

Error packets are transmitted asynchronously from the data node over the command
socket. In the FPGA firmware, a fixed number of registers can be configured as
error registers. Any changes on these registers will cause an Error Packet to be
transmitted, along with the current values of all other error registers. More
than one error register may be changed within a single error packet.

In order to prevent flooding, the remote host must clear the error register with
a typical request packet.
=======
TODO finish.
>>>>>>> 5d1b3aba48fb67cc0f9dac765e19923a761b1ec4
