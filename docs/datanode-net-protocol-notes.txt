NB:

- These are notes. They are incomplete and not yet a coherent draft or
  proposal.
- This file uses terms defined in system-overview.txt.

TODO:

- Board subsample configuration requests
- Sector-based I/O commands

# Context

This document proposes a network protocol for bi-directional data acquisition
and control communications between a "Wired Leaf" data node and a daemon
running on an analysis server or user workstation.

It is a design goal that at least a useful subset of this protocol can be
implemented in HDL running on the FPGA so that a basic system can be brought
online without any additional processor firmware beyond a trivial management of
the TCP interface and data pass through.

To achieve this property, each of the primary cores that comprise the FPGA
firmware will expose key operational and configuration registers to a global
regmap. This regmap can be accessed via this protocol. Thus, the burden of the
application and other glue logic *can* be moved to the remote server by issuing
longer sequences of reads and writes on this exposed regmap.

Ideally, any command which poses a substantial additional burden on the logic of
the FPGA core or demands the inclusion of substantial firmware running on a soft
or hard processor can be circumvented via an appropriate sequence of operations
on the system registers.

The data node SHOULD process one command or request (aside from live data
streaming) at a time; if another request arrives while processing, it MAY queue
the request or reply with an error.

Two sockets are used: one bi-directional command/control socket (type
SOCK_STREAM), and one uni-directional data socket (type SOCK_DGRAM). The data
socket is used to stream sample data from the FPGA board to the computer. The
command socket is bidirectional and low-bandwidth; the data socket is
unidirectional and high-bandwidth.

# Packet Format

TODO: decide on port numbers

The source address serves to identify the unique acquisition device. All
packets have a fixed size.

    [UDP/IPv4 pseudo header]
        Source address (4 B)
        Destination address (4 B)
        Zeros (0x00) | Protocol Number (0x11 for UDP) | UDP length (2 B)
    [UDP header]
        Source Port (2 B) | Destination Port (2 B)
        Length (2 B) | Checksum (2 B)
    [SNG Wire Format Header]
        Magic number (1 B) | Proto Version (1 B) | Message Type (1 B) | Status Flags (1 B)
    [SNG Message Data]
        (contents depend upon Message Type. Length fixed to 8 bytes on command
        socket; variable on data socket)

The Status Flags byte reserves the high bit (bit 7) to indicate a generic error
condition. The other bits are reserved on a per-Message Type basis.

The valid values for the Message Type field, and their meanings, are:

- Request: 0x02
- Response: 0x03
- Board Sub-Sample: 0x04
- Board Sample: 0x05
- Remote Error: 0x06

Important: 0x00 is an invalid Message Type, which is reserved for internal use
by the daemon.

# Message Types

## Request (0x02)

A packet with Message type equal to 0x02 indicates a request. Request packets
are sent only from the daemon to the data node, on the command socket.

Additional flags:

- I/O direction: bit 0 signals whether a request which performs some sort of
  input/output is a read (bit 0 set) or a write (bit 0 unset).

Message Data:

    Request ID (2 B) | Request Type (1 B) | Request Address (1 B, or zeros)
    Request Value (4 B)

The Request ID field is used to associate responses with requests. The request
ID field SHOULD be an incrementing 16-bit unsigned integer which wraps back to
zero after 0xFFFF is reached.


The Request Type field identifies the data node subsystem to which the request
pertains. Each of the request types correspond to a specific HDL core that
comprises the toplevel FPGA firmware. This guarantees that each such module has
a full byte of address space dedicated to its own registers.
Valid Request Types are:

- Storage/disk (0x02): e.g. disk sector index, I/O status
- DAQ (0x03): e.g. reconfiguration of front end, impedance measurement
- Network (0x04): e.g. source/dest IP address, dest. MAC address
- Expansion (0x05): e.g. GPIO configuration for expansion header pins
- Acquisition (0x06): start, stop acquisition, configure board subsample
- Retrieval (0x07): Read board sample packets off disk.
- Error (0x08)

The Request Address field identifies a register address. Whether the request is
for a read or write to the address is determined by the I/O direction flag
discussed above.

Currently, all specified registers are 32-bits long. Accessing registers that are
functionally longer than 4 bytes - for example the dest MAC address - must be
done over multiple packets. This is done for ease of implementation. It is
expected that in the future specific registers may vary in length between 1 and
12 bytes.

### Storage/Disk (0x02)
### DAQ (0x03)
### Network (0x04)
### Expansion (0x05)
### Acquisition (0x06)
### Retrieval (0x07)

### Error (0x08)
There is only one error register, 0x00, which must be cleared in order to allow
additional error packets to be transmitted over the asynchronous error channel.


## Response (0x3)

A Response packet contains the same fields as a request packet. Response
packets are sent from the data node to the daemon, on the command socket. The
meaning of the I/O direction flag in a response packet is not defined.

After processing a request packet, the data node replies with a response
packet. The response packet has the same Request ID as that in the request
packet. The Request Type and Request Address fields in the response packet
SHOULD be the same as those in the request packet.

    Response ID (2 B) | Response Type (1 B) | Address (1 B, or zeros)
    Response value (4 B, or zero)

TODO: spec out Message Data when different from Request packets

## Board Sub-Sample Packet (0x4)

Contains a variable number of channel samples, all taken from the same board
sample. Board subsample packets are sent only from the data node to the daemon,
on the data socket.

Additional flags:

- is_live (live acquisition vs. read from disk)
- is_last_sample: bit 1 set indicates no more samples will follow; this makes
  daemon control structure much simpler.

Message Data:

    Experiment Timestamp High (4 B)
    Experiment Timestamp Low (4 B)
    Board ID (4 B)
    Start channel index (4 B)
    NSAMP=Number of channels (4 B)
    [... sequence of NSAMP channel readings ]
    Chip N, Chan M data (2 B) | Chip N, Chan M+1 data (2 B)

The start sample index indicates the index of the first channel in the
subsample, relative to the start of the board sample. We use 32 bits to allow
for future expansion to systems with more than 65K channels.

Sample indexes are calculated as follows:

    sample index 0 = chip 0, channel 0
    sample index 1 = chip 0, channel 1
    ...
    sample index n = chip 0, channel n
    sample index n+1 = chip 1, channel 0

TBD: multiple board subsamples may get bundled into a single packet to improve
aggregate ethernet data throughput?

NB: Board Subsample packets, which are received over the data socket, are
likely to be of a fixed length (18kilobit?), regardless of how much meaningful
data is enclosed.


## Board Sample Packet (0x05)

Contains a sample from each available channel, all taken during the same
sampling interval. Board sample packets are sent only from the data node to
the daemon, on the data socket.

The raw channel data is up to 32 chips x 32 channels x 16bit x 1 sample, plus
lower frequency extras (the 32 chips x 3 channels x 16bit of auxiliary ADC
input). Totals to 1120 channels, or 2240 bytes.

A 64bit "Experiment Cookie" is used as a unique identifier for a given
acquisition run (initially, we'll use a Unix timestamp as a cookie, but you
should treat it as an opaque value). A 32bit sample index identifies both a
unique board sample within an experimental acquisition run and a position on
the node's disk cache.  A 32bit Board ID is a unique identifier for the
acquistion node's hardware.

Flags:
- is_live (live acquisition vs. read from disk)
- is_last_sample (no more samples will follow; makes daemon control structure
  much simpler)

    Experiment Timestamp High (4 B)
    Experiment Timestamp Low (4 B)
    Board ID (4 B)
    Sample Index (4 B)
        [2240 Bs of channel and AUX data follow]
    Channel 00 (2 B) | Channel 01 (2 B)
    Channel 02 (2 B) | Channel 03 (2 B)
    [...]
    Channel 1118 (2 B) | Channel 1119 (2 B)

This totals to 2256 bytes, so a board sample packet is 2284 bytes total.

NB: The Board Sample has the same binary representation as the "Wrapped Board
Sample"; see documentation in the FPGA HDL repository (sng-firmware) for the
exact channel ordering and round-robin scheme.


## Error Packet (0x06)

Error packets are transmitted asynchronously from the data node over the command
socket. In the FPGA firmware, a fixed number of registers can be configured as
error registers. Any changes on these registers will cause an Error Packet to be
transmitted.

Error packets have no extra data.

In order to prevent flooding, the remote host must clear all error registers (with
request packets) before further Error Packets are transmitted.

