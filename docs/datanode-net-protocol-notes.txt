NB:

- These are notes. They are incomplete and not yet a coherent draft or
  proposal.
- This file uses terms defined in system-overview.txt.
- In this file, the unit 'B' means "byte", not to be confused with "bit"

TODO:

- Board subsample configuration requests
- Sector-based I/O commands

# Context

This document proposes a network protocol for bi-directional data acquisition
and control communications between a "Wired Leaf" data node and a daemon
running on an analysis server or user workstation.

It is a design goal that at least a useful subset of this protocol can be
implemented in HDL running on the FPGA so that a basic system can be brought
online without any additional processor firmware beyond a trivial management of
the TCP interface and data pass through.

To achieve this property, each of the primary cores that comprise the FPGA
firmware will expose key operational and configuration registers to a global
regmap. This regmap can be accessed via this protocol. Thus, the burden of the
application and other glue logic *can* be moved to the remote server by issuing
longer sequences of reads and writes on this exposed regmap.

Ideally, any command which poses a substantial additional burden on the logic of
the FPGA core or demands the inclusion of substantial firmware running on a soft
or hard processor can be circumvented via an appropriate sequence of operations
on the system registers.

The data node SHOULD process one command or request (aside from live data
streaming) at a time; if another request arrives while processing, it MAY queue
the request or reply with an error.

Two sockets are used: one bi-directional command/control socket (type
SOCK_STREAM), and one uni-directional data socket (type SOCK_DGRAM). The data
socket is used to stream sample data from the FPGA board to the computer. The
command socket is bidirectional and low-bandwidth; the data socket is
unidirectional and high-bandwidth.

# Packet Format

TODO: decide on port numbers

The source address serves to identify the unique acquisition device. All
command packets have a fixed size; this makes it easy to segment the stream
into packets. Data packets have variable size. Both types of packets contain
the following fields.

    [SNG Wire Format Header]
        Magic number (1 B) | Proto Version (1 B) | Message Type (1 B) | Status Flags (1 B)
    [SNG Message Data]
        (contents depend upon Message Type. Length fixed to 8 bytes on command
        socket; variable on data socket)

The Magic number is 0x5A.

The data streamed in each direction on the command socket is thus a sequence of
12 byte command packets. The datagrams streamed on the data socket are a
sequence of data commands, each of which begins with the above fields at
payload offset zero.

The Status Flags byte reserves the high bit (bit 7) to indicate a generic error
condition. The other bits are reserved on a per-Message Type basis.

The valid values for the Message Type field, and their meanings, are:

Command packets:

- Request: 0x01
- Response: 0x02
- Remote Error: 0x7F

Data packets:

- Board Sub-Sample: 0x80
- Board Sample: 0x81

Important: 0x00 is an invalid Message Type, which is reserved for internal use
by the daemon.

# Message Types

## Request (0x01)

A packet with Message type equal to 0x02 indicates a request. Request packets
are sent only from the daemon to the data node, on the command socket.

Additional flags:

- I/O direction: bit 0 signals whether a request is a read (bit 0 set) or a
  write (bit 0 unset).

Message Data:

    Request ID (2 B) | Request Type (1 B) | Request Address (1 B)
    Request Value (4 B)

The Request ID field is used to associate responses with requests. The request
ID field SHOULD be an incrementing 16-bit unsigned integer which wraps back to
zero after 0xFFFF is reached.

The Request Type field identifies the data node subsystem to which the request
pertains. Each of the request types correspond to a specific HDL core that
comprises the toplevel FPGA firmware. This guarantees that each such module has
a full byte of address space dedicated to its own registers.
Valid Request Types are:

- Error (0x00): bitmask of module error statuses
- Top Level Module (0x01): top-level system coordination module
- SATA Module (0x02): e.g. disk sector index, I/O status
- DAQ Module (0x03): e.g. reconfiguration of front end, impedance measurement
- UDP Module (0x04): e.g. source/dest IP address, dest. MAC address
- Expansion Pins (0x05): e.g. GPIO configuration for expansion header pins

The Request Address field identifies a register address. Whether the request is
for a read or write to the address is determined by the I/O direction flag
discussed above.

In case of a write Request, the Request Value contains 4 bytes to be written to
the register. In case of a read Request, the Request Value MUST be zero.

All registers are 32 bits wide. Accessing registers that are functionally
longer than 4 bytes - for example, the destination MAC address - must be done
using multiple Requests.

TODO: specify the valid addresses for these Request Types:

### Error (0x00)

0x00    R/W     Unused (3 B) | Module error flags (1 B)

There is only one error register, 0x00, which must be cleared in order to allow
additional error packets to be transmitted over the asynchronous error channel.
Each bit of this register represents a module, with the bit number being the
module address used in Requests.

### Top Level Module (0x01)

0x00    R/W     Unused (3 B) | Module error flags (1 B)
0x01    R/W     Unused (3 B) | Top Level Module State (1 B)
0x02    R/W     Experiment Identifier, top bytes (4 B)
0x03    R/W     Experiment Identifier, bottom bytes (4 B)
0x10    R/W     Partial sample channel bitmask, Ch 0 to 31 (4 B)
0x11    R/W     Partial sample channel bitmask, Ch 32 to 63 (4 B)
[...]
0x2F    R/W     Partial sample channel bitmask, Ch 992 to 1023 (4 B)

### SATA Module (0x02)

0x00    R/W     Error/Status (TBD)
0x01    R/W     Unused (3 B) | SATA Module State (1 B)
0x02    R/O     Disk Identifier (?)
0x03    R/W     Disk I/O parameters (eg, speed?)
0x04    R/W     Next Read Index (4 B)
0x05    R/W     Read Length (4 B)
0x06    R/O     Last Write Index (4 B)

### DAQ Module (0x03)

0x00    R/W     Error/Status (TBD)
0x01    R/W     Unused (3 B) | DAQ Module State (1 B)
0x02    R/W     Desired Start Board Sample Number (4 B)
0x03    R/O     Current Board Sample Number (4 B)
0x04    R/O     Chip alive bitmask (4 B)
0x05    R/W     CMD Write Enable (1 B) | CMD Chip Address (1 B) | CMD Command (2 B)

### UDP Module (0x04)

0x00    R/W     Error/Status (TBD)
0x01    R/W     Unused (3 B) | UDP Module State (1 B)
0x02    R/O     Unused (2 B) | Source MAC-48 Address Top bytes (2 B)
0x03    R/O     Source MAC-48 Address Bottom bytes (4 B)
0x04    R/W     Unused (2 B) | Destination MAC-48 Address Top bytes (2 B)
0x05    R/W     Destination MAC-48 Address Bottom bytes (4 B)
0x06    R/W     Source IPv4 Address (4 B)
0x07    R/W     Destination IPv4 Address (4 B)
0x08    R/W     Unused (2 B) | Source IPv4 Port (2 B)
0x09    R/W     Unused (2 B) | Destination IPv4 Port (2 B)
0x0A    R/W     More configuration (TBD)

### Expansion Pins (0x05)

0x00    R/W     Error/Status (TBD)
0x01    N/A     (no state machine for GPIO pins)
0x02    R/0     Unused (2 B) | Available GPIO mask (2 B)
0x03    R/W     Unused (2 B) | GPIO state (2 B)


## Response (0x02)

A Response packet contains the same fields as a request packet. Response
packets are sent from the data node to the daemon, on the command socket. The
meaning of the I/O direction flag in a response packet is not defined.

After processing a request packet, the data node replies with a response
packet. The response packet has the same Request ID as that in the request
packet. The Request Type and Request Address fields in the response packet
SHOULD be the same as those in the request packet.

    Response ID (2 B) | Response Type (1 B) | Address (1 B, or zeros)
    Response value (4 B, or zero)

In case of a Response to a write Request (i.e., I/O direction bit unset), the
Response Value will equal the value written. In case of a Response to a read
Request (i.e., I/O direction bit set), the Response Value will contain the value
of the register which was read.


## Remote Error (0x7F)

Error packets are transmitted asynchronously from the data node over the command
socket. In the FPGA firmware, a fixed number of registers can be configured as
error registers. Any changes on these registers will cause an Error Packet to be
transmitted.

Error packets have no extra data. Their SNG Message Data area MUST be zero.

In order to prevent flooding, the remote host must clear all error registers (with
request packets) before further Error Packets are transmitted.


## Board Sub-Sample Packet (0x80)

Contains a variable number of channel samples, all taken from the same board
sample. Board subsample packets are sent only from the data node to the daemon,
on the data socket.

Additional flags:

- is_live (live acquisition vs. read from disk)
- is_last_sample: bit 1 set indicates no more samples will follow; this makes
  daemon control structure much simpler.

Message Data:

    Experiment Cookie High (4 B)
    Experiment Cookie Low (4 B)
    Board ID (4 B)
    Start channel index (4 B)
    NSAMP=Number of channels (4 B)
    [... sequence of NSAMP channel readings ]
    Chip N, Chan M data (2 B) | Chip N, Chan M+1 data (2 B)

The start sample index indicates the index of the first channel in the
subsample, relative to the start of the board sample. We use 32 bits to allow
for future expansion to systems with more than 65K channels.

Sample indexes are calculated as follows:

    sample index 0 = chip 0, channel 0
    sample index 1 = chip 0, channel 1
    ...
    sample index n = chip 0, channel n
    sample index n+1 = chip 1, channel 0

TBD: multiple board subsamples may get bundled into a single packet to improve
aggregate ethernet data throughput?

NB: Board Subsample packets, which are received over the data socket, are
likely to be of a fixed length (18kilobit?), regardless of how much meaningful
data is enclosed.


## Board Sample Packet (0x81)

Contains a sample from each available channel, all taken during the same
sampling interval. Board sample packets are sent only from the data node to
the daemon, on the data socket.

The raw channel data is up to 32 chips x 32 channels x 16bit x 1 sample, plus
lower frequency extras (the 32 chips x 3 channels x 16bit of auxiliary ADC
input). Totals to 1120 channels, or 2240 bytes.

A 64bit "Experiment Cookie" is used as a unique identifier for a given
acquisition run (initially, we'll use a Unix timestamp as a cookie, but you
should treat it as an opaque value). A 32bit sample index identifies both a
unique board sample within an experimental acquisition run and a position on
the node's disk cache.  A 32bit Board ID is a unique identifier for the
acquistion node's hardware.

Flags:
- is_live (live acquisition vs. read from disk)
- is_last_sample (no more samples will follow; makes daemon control structure
  much simpler)

    Experiment Cookie High (4 B)
    Experiment Cookie Low (4 B)
    Board ID (4 B)
    Sample Index (4 B)
    Chip Live Status (4 B)
        [2240 Bs of channel and AUX data follow]
    Channel 00 (2 B) | Channel 01 (2 B)
    Channel 02 (2 B) | Channel 03 (2 B)
    [...]
    Channel 1118 (2 B) | Channel 1119 (2 B)

This totals to 2260 bytes, so a board sample packet is 2288 bytes total.

NB: The Board Sample has the same binary representation as the "Wrapped Board
Sample"; see documentation in the FPGA HDL repository (sng-firmware) for the
exact channel ordering and round-robin scheme.

