NB:

- These are notes. They are incomplete and not yet a coherent draft or
  proposal.
- This file uses terms defined in system-overview.txt.

TODO:

- Board subsample configuration requests
- Sector-based I/O commands

# Context

This document proposes a network protocol for bi-directional data acquisition
and control communications between a "Wired Leaf" data node and a daemon
running on an analysis server or user workstation.

It is not a design goal for this protocol to be implementable in raw digital
logic on the FPGA device; it is expected that there is a translation layer from
these packets to the FPGA which relies on a soft- or hard-core general purpose
processor.

The data node SHOULD process one command or request (aside from live data
streaming) at a time; if another request arrives while processing, it MAY queue
the request or reply with an error.

Two sockets are used: one bi-directional command/control socket (type
SOCK_STREAM), and one uni-directional data socket (type SOCK_DGRAM). The data
socket is used to stream sample data from the FPGA board to the computer. The
command socket is bidirectional and low-bandwidth; the data socket is
unidirectional and high-bandwidth.

# Packet Format

TODO: decide on port numbers

The source address serves to identify the unique acquisition device. All
packets have a fixed size.

    [UDP/IPv4 pseudo header]
        Source address (4byte)
        Destination address (4byte)
        Zeros (0x00) | Protocol Number (0x11 for UDP) | UDP length (2byte)
    [UDP header]
        Source Port (2byte) | Destination Port (2byte)
        Length (2byte) | Checksum (2byte)
    [SNG Wire Format Header]
        Magic number (1byte) | Proto Version (1byte) | Message Type (1byte) | Misc Flags (1byte)
    [Error Status]
        Error flags (4bytes)
    [SNG Message Data]
        (contents depend upon Message Type. Length fixed to 16 bytes on command
        socket; variable on data socket)

The Error status word has up to 32 flags to indicate various error conditions.
If any bit is high, the daemon should read and write to specific registers
using request packets to resolve the error and reset the flag bits.

The valid values for the Message Type field, and their meanings, are:

- Request: 0x02
- Response: 0x03
- Board subsample: 0x04
- Disk sectors: 0x05

# Message Types

## Request (0x02)

A packet with Message type equal to 0x02 indicates a request. Request packets
are sent only from the daemon to the data node, on the command socket.

Additional flags:

- I/O direction: bit 0 signals whether a request which performs some sort of
  input/output is a read (bit 0 set) or a write (bit 0 uset).

Message Data:

    Request ID (2byte) | Request Type (1byte) | Request Address (1byte, or zeros)
    Extra data (12 bytes, or garbage)

The Request ID field is used to associate responses with requests. The request
ID field SHOULD be an incrementing 16-bit unsigned integer which wraps back to
zero after 0xFFFF is reached.

The Request Type field identifies the data node subsystem to which the request
pertains. Valid Request Types are:

- Storage/disk (0x02): e.g. disk sector index, I/O status
- DAQ (0x03): e.g. reconfiguration of front end, impedence measurement
- Network (0x04): e.g. source/dest IP address, dest. MAC address
- Expansion (0x05): e.g. GPIO configuration for expansion header pins
- Acquisition (0x06): start, stop acquisition, configure board subsample

The Request Address field identifies a register address. Whether the request is
for a read or write to the address is determined by the I/O direction flag
discussed above.

NB: depending on the destination address (which represents a core register),
the data width may vary from one to 12 bytes. It may also be the case that a
single functional register will be spread across several subregisters of a
fixed size (eg, a 64 bit value spread across 8x 8bit registers), each of which
would need to be written to by a seperate request packet. This flexibility is
reserved to make data node firmware implementation easier.

TODO: spec out Request Address and Message Data on a per-r_type basis.

## Response (0x3)

A Response packet contains the same fields as a request packet. Response
packets are sent from the data node to the daemon, on the command socket. The
meaning of the I/O direction flag in a response packet is not defined.

After processing a request packet, the data node replies with a response
packet. The response packet has the same Request ID as that in the request
packet. The Request Type and Request Address fields in the response packet
SHOULD be the same as those in the request packet.

TODO: spec out Message Data when different from Request packets

## Board Subsample (0x4)

Contains a variable number of channel samples, all taken from the same board
sample. Board subsample packets are sent only from the data node to the daemon,
on the data socket.

Additional flags:

- Is last sample: bit 1 set indicates no more samples will follow; this makes
  daemon control structure much simpler.

Message Data:

    Start sample index (4 byte)
    NSAMP=Number of samples (4 byte)
    [... sequence of NSAMP channel readings ]

The start sample index indicates the index of the first channel in the
subsample, relative to the start of the board sample. We use 32 bits to allow
for future expansion to systems with more than 65K channels.

Sample indexes are calculated as follows:

    sample index 0 = chip 0, channel 0
    sample index 1 = chip 0, channel 1
    ...
    sample index n = chip 0, channel n
    sample index n+1 = chip 1, channel 0

TBD: multiple board subsamples may get bundled into a single "Board Subsample"
to improve agregate data throughput?

NB: Board Subsample packets, which are received over the unidirectional UDP
socket, are likely to be of a fixed length (18kilobit?), regardless of how much
meaningful data is enclosed.

## Sector reading (0x5)

Contains a variable number of disk sectors read by the data node. Sector
reading packets are sent only from the data node to the daemon, on the data
socket.

TODO finish.

NB: Board Subsample packets, which are received over the unidirectional UDP
socket, are likely to be of a fixed length (18kilobit?), regardless of how much
meaningful data is enclosed.
